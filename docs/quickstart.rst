Quick start
===========

This section will introduce you to Unfurl by creating a simple project that deploys a web application. Once you get this working, you can customize it for your own application. 

.. tip::
  The steps here follow the high-level overview of Unfurl found in the `solution-overview` section.

Step 1 Create a project

The first step is to create an Unfurl project to manage -- to create a project, run this command:

.. code-block:: shell

    unfurl init myproject --empty

This is will create an Unfurl project in directory "myproject".  The ``--empty`` option skips creating an ensemble (a deployment) for now (we'll add that in step 3).

If this is the first time you've created a Unfurl project, you'll notice a message like "Unfurl home created at ~/.unfurl_home".  Unfurl home is an Unfurl project that contains local settings and resources that are shared with other projects on that machine, including an isolated execution environment to run Unfurl in. For more information, see `.unfurl_home<Unfurl Home>`.

Step 2: Describe your application

Now the your project is set up let's deploy a web app. Let's consider a simple nodejs app that connects to a Postgres database

In ensemble-template.yaml we'll define our web app at a high-level.

Our web app is a container image. 

* We to create a service that can run the container image.
* Need to have access to a database and connect to the database.
* It also needs to hooked up to DNS.

The TOSCA specification defines types that provide basic abstractions for resources like compute instances and container images. In addition, we've developed the |stdlib|_.

Open ``service_template.py`` and add these lines:

.. code-block:: python

  import tosca
  from tosca_repositories import std

Now run ``unfurl validate``. This will make sure your changes are validate but more importantly it will clone the std repository and now if you edit the Python in an editor such as VS Code the package import should resolve with all of your editor's type checking and code navigation enabled.

For our example we'll use these types to model our application:

.. tab-set-code::

  .. code-block:: python

    db = PostgresSQL()

    container = ContainerService(
      unfurl.datatypes.EnvironmentVariables(
        DBASE=db.url,
        URL=WebApp.url
      )
      host_requirement=host
    )

    host=ContainerHost()

    __root__ = WebApp(
      container=container,
      db=db,
      subdomain="myapp"
    )

  .. code-block:: YAML

    topology_template:
      node_templates:
        db:
          type: PostgresDB
        container:
          type: ContainerService
          properties:
            environment:
              # theses environment variables' values are evaluated during deployment
              # (the expressions are generated by the above Python code)
              DBASE:
                eval: ::db::url  
              url:
                eval: ::[.type=SQLWebApp]::url
            container:
              image: registry.gitlab.com/gitlab-org/project-templates/express/main:latest
              ports:
              - 5000:5000

        __root__:
          type: SQLWebApp
          requirements:
          - container: container
          - db: db
          properties:
            subdomain: myapp
      
      substitution_mappings:
        node: d.__root__

Step 3 Instantiate your blueprint

Now we have a model that we can customize for different environments.
In this example, let's suppose there are two types of environments we want to deploy this into:

* a production environment that deploys to AWS and using AWS RDS database
* a development environments that runs the app and Postgres as services in a Kubernetes cluster

Let's create those environments, along with a deployment for each:

.. code-block:: shell

   cd myproject
   unfurl init production --skeleton aws --use-environment production
   unfurl init development --skeleton k8s --use-environment development

The ``--skeleton`` option lets you specify an alternative to the default project skeleton. We'll assume we're deploying it into AWS so we will use the ``aws`` project skeleton. You can see all the built-in project skeletons :unfurl_github_tree:`here <unfurl/skeletons>` or use an absolute path to specify your own. 

.. important::

  Store the master password found in ``ensemble/local/unfurl.yaml`` in a safe place! By default this password is used to encrypt any sensitive data committed to repository. See :doc:`secrets` for more information.

There are different approaches to customize a blueprint but simple one is to declare deployment blueprints. A `deployment blueprint` is a blueprint that is only applied when its criteria matches the deployment environment. It inherits an application blueprint and includes node templates that override the blueprint's.

Ensemble's ``deployment_blueprints``  In Python, a `deployment blueprint` is represented as a Python class with the customized template objects as class attributes.

.. tab-set-code::

    .. code-block:: python

      class production(DeploymentBlueprint):
          _cloud = "unfurl.relationships.ConnectsTo.AWSAccount"

          # XXXXXX!!!
          host = ComputeContainerHost(host=EC2())
          db = RDS

      class dev(DeploymentBlueprint):
          _cloud = "unfurl.relationships.ConnectsTo.K8sCluster"

          host = PublicK8sThingy()
          db = PostgresDBInstance(database_name="thedb",    
                  root_password="passw", 
                              host_requirement=None)

    .. code-block:: YAML

        deployment_blueprints:
          production:
            cloud: unfurl.relationships.ConnectsTo.AWSAccount
          dev:
            cloud: unfurl.relationships.ConnectsTo.K8sCluster
            node_templates:
              db:
                type: PostgresDBInstance
                properties:
                  root_password: passw
                  database_name: thedb

Here we are using existing implementations defined in the std library -- to write your own, check out our examples for adding `Ansible` playbooks, `Terraform` modules or invoking `shell` commands. ((Or continue reading for a more in-depth Getting Started guide.))

Now if we run :cli:`unfurl plan<unfurl-plan>`

Step 4. Deploy and manage

Now we're ready to deploy our application.
Run :cli:`unfurl deploy development<unfurl-deploy>` from the command line and it will execute the plan.

Deploy Use :cli:`unfurl deploy<unfurl-deploy>` to deploy the infrastructure.  It will commit to git the latest configuration and a history of changes to your cloud accounts.

Now we can delete this using :cli:`unfurl teardown<unfurl-teardown>`.

Step 5. Share, clone, and remix

publish (anywhere, on unfurl.cloud)?
------------------------------------

You can push your repository to a git service such as Github or Gitlab to share it. We just have to configure git remotes for the git repositories we created.

When we ran :cli:`unfurl init<unfurl-init>` it creating a separate git repository for each ensemble (the --mono, --existing, --submodule, and --shared-repository options all modify that behavior). This allows project's blueprints and deployments to have separate histories and access control.

:cli:`unfurl git-status<unfurl-git-status>` will show the location and git status of each repository the project manages.

:cli:`unfurl git <git command line><unfurl-git>` will run the given git command on each repository the project manages, so you can run :cli:`unfurl git push<unfurl-git>` after you set up the remotes. Or you can use the ``--push`` option with Unfurl's :cli:`deploy commands<unfurl-deploy-commands>` to have Unfurl automatically push any committed after the job finishes.

cloning
-------

Now that the project's repositories are hosted, we can use the :cli:`unfurl clone<unfurl-clone>` command to clone and deploy from the project on other machines.  

If you want to create a new deployment from the blueprint, clone the blueprint repository, unfurl clone will create a new ensemble unless the ``--empty`` flag is used.

If you want to manage one of the deployment we already deployed, clone the repository that has that ensemble. 

.. tip::

  If you had used ``--submodule`` option with :cli:`unfurl init<unfurl-init>` or manually submodule using ``git submodule add`` then the clone command would have cloned those to.

When deploying, you can configure to use a remote lock so that two deployments.

You can embed the blueprint
You can share , for example, to 

..

To be able to deploy updates to that ensemble, you might need to update your local environment to work with it (for example, cloud provider credentials for the account it was deployed into).
There are a few ways to do that without modifying the unfurl.yaml that is part of the repository:

* add the environment to `.unfurl_home<unfurl home>`
* clone the repository inside an existing Unfurl project ``unfurl clone myensemble.git existing_project/myensemble`` -- the project unfurl.yaml will be merged during deployment.
